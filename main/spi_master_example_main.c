#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "driver/spi_master.h"
#include "soc/gpio_struct.h"
#include "driver/gpio.h"
#include <driver/adc.h>
#include <esp_adc_cal.h>



#include "ssd1306_consts.h"

#define PIN_NUM_MISO 25
#define PIN_NUM_MOSI 23
#define PIN_NUM_CLK  19
#define PIN_NUM_CS   22

#define PIN_NUM_DC   16
#define PIN_NUM_RST  18

//Send a command to the LCD. Uses spi_device_transmit, which waits until the transfer is complete.
void lcd_cmd(spi_device_handle_t spi, const uint8_t* cmd, int len)
{
    esp_err_t ret;
    spi_transaction_t t;
    memset(&t, 0, sizeof(t));       //Zero out the transaction
    t.length=8 * len;                     //Command is 8 bits
    t.tx_buffer=cmd;               //The data is the cmd itself
    t.user=(void*)0;                //D/C needs to be set to 0
    ret=spi_device_transmit(spi, &t);  //Transmit!
    assert(ret==ESP_OK);            //Should have had no issues.
}

//Send data to the LCD. Uses spi_device_transmit, which waits until the transfer is complete.
void lcd_data(spi_device_handle_t spi, const uint8_t *data, int len)
{
    esp_err_t ret;
    spi_transaction_t t;
    if (len==0) return;             //no need to send anything
    memset(&t, 0, sizeof(t));       //Zero out the transaction
    t.length=len*8;                 //Len is in bytes, transaction length is in bits.
    t.tx_buffer=data;               //Data
    t.user=(void*)1;                //D/C needs to be set to 1
    ret=spi_device_transmit(spi, &t);  //Transmit!
    assert(ret==ESP_OK);            //Should have had no issues.
}

//This function is called (in irq context!) just before a transmission starts. It will
//set the D/C line to the value indicated in the user field.
void lcd_spi_pre_transfer_callback(spi_transaction_t *t)
{
    int dc=(int)t->user;
    gpio_set_level(PIN_NUM_DC, dc);
}

//Initialize the display
void lcd_init(spi_device_handle_t spi)
{
    //Initialize non-SPI GPIOs
    gpio_set_direction(PIN_NUM_DC, GPIO_MODE_OUTPUT);
    gpio_set_direction(PIN_NUM_RST, GPIO_MODE_OUTPUT);

    printf("SSD1306\n");

    //Reset the display
    gpio_set_level(PIN_NUM_RST, 1);
    vTaskDelay(1 / portTICK_PERIOD_MS);
    gpio_set_level(PIN_NUM_RST, 0);
    vTaskDelay(1);
    gpio_set_level(PIN_NUM_RST, 1);
    vTaskDelay(1);

    uint8_t cmd1[] = {SSD1306_DISPLAYOFF, SSD1306_SETDISPLAYCLOCKDIV, 0x80};
    uint8_t cmd2[] = {SSD1306_SETMULTIPLEX, SSD1306_LCDHEIGHT - 1};
    uint8_t cmd3[] = {SSD1306_SETDISPLAYOFFSET, 0x00, SSD1306_SETSTARTLINE | 0x00};
    uint8_t cmd4[] = {SSD1306_CHARGEPUMP, 0x14};
    uint8_t cmd5[] = {SSD1306_MEMORYMODE, 0x00};
    uint8_t cmd6[] = {SSD1306_SEGREMAP | 0x1, SSD1306_COMSCANDEC};
    uint8_t cmd7[] = {SSD1306_SETCOMPINS, 0x12};
    uint8_t cmd8[] = {SSD1306_SETCONTRAST, 0xCF}; // SSD1306_SWITCHCAPV
    uint8_t cmd9[] = {SSD1306_SETPRECHARGE, 0xF1}; // SSD1306_SWITCHCAPV
    uint8_t cmdA[] = {SSD1306_SETVCOMDETECT, 0x40};
    uint8_t cmdB[] = {SSD1306_DISPLAYALLON_RESUME, SSD1306_NORMALDISPLAY, SSD1306_DEACTIVATE_SCROLL,
                      SSD1306_DISPLAYON};
    uint8_t cmdC[] = {SSD1306_COLUMNADDR, 0, SSD1306_LCDWIDTH - 1};
    uint8_t cmdD[] = {SSD1306_PAGEADDR, 0, 7};

    lcd_cmd(spi, cmd1, sizeof(cmd1));
    lcd_cmd(spi, cmd2, sizeof(cmd2));
    lcd_cmd(spi, cmd3, sizeof(cmd3));
    lcd_cmd(spi, cmd4, sizeof(cmd4));
    lcd_cmd(spi, cmd5, sizeof(cmd5));
    lcd_cmd(spi, cmd6, sizeof(cmd6));
    lcd_cmd(spi, cmd7, sizeof(cmd7));
    lcd_cmd(spi, cmd8, sizeof(cmd8));
    lcd_cmd(spi, cmd9, sizeof(cmd9));
    lcd_cmd(spi, cmdA, sizeof(cmdA));
    lcd_cmd(spi, cmdB, sizeof(cmdB));
    lcd_cmd(spi, cmdC, sizeof(cmdC));
    lcd_cmd(spi, cmdD, sizeof(cmdD));
}

void lcd_draw_pixel(uint8_t *frame, int x, int y)
{
  if(x < 0 || x >= SSD1306_LCDWIDTH || y < 0 || y >=SSD1306_LCDHEIGHT)
  {
    return;
  }
  frame[x+ (y/8)*SSD1306_LCDWIDTH] |= (1 << (y&7));
}


void app_main()
{
    esp_err_t ret;
    spi_device_handle_t spi;
    spi_bus_config_t buscfg={
        .miso_io_num=PIN_NUM_MISO,
        .mosi_io_num=PIN_NUM_MOSI,
        .sclk_io_num=PIN_NUM_CLK,
        .quadwp_io_num=-1,
        .quadhd_io_num=-1,
        .max_transfer_sz=128*64*8
    };
    spi_device_interface_config_t devcfg={
        .clock_speed_hz=2*1000*1000,           //Clock out at 2 MHz
        .mode=0,                                //SPI mode 0
        .spics_io_num=PIN_NUM_CS,               //CS pin
        .queue_size=7,                          //We want to be able to queue 7 transactions at a time
        .pre_cb=lcd_spi_pre_transfer_callback,  //Specify pre-transfer callback to handle D/C line
    };
    //Initialize the SPI bus
    ret=spi_bus_initialize(HSPI_HOST, &buscfg, 1);
    ESP_ERROR_CHECK(ret);
    //Attach the LCD to the SPI bus
    ret=spi_bus_add_device(HSPI_HOST, &devcfg, &spi);
    ESP_ERROR_CHECK(ret);
    //Initialize the LCD

    uint8_t frame[SSD1306_LCDWIDTH * SSD1306_LCDHEIGHT / 8];
/*    uint8_t frame[]  = {0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F, */
/* 0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF, */
/* 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F, */
/* 0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0, */
/* 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, */
/* 0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E, */
/* 0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC, */
/* 0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06, */
/* 0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8, */
/* 0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, */
/* 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C, */
/* 0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, */
/* 0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, */
/* 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07, */
/* 0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/* 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
/*     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} */;
    lcd_init(spi);
    int x = 0;
    int y = 0;
    int z = 0;

    adc1_config_width(ADC_WIDTH_12Bit);
    adc1_config_channel_atten(ADC1_CHANNEL_6, ADC_ATTEN_11db);

    /* // Calculate ADC characteristics i.e. gain and offset factors */
    /* esp_adc_cal_characteristics_t characteristics; */
    /* esp_adc_cal_get_characteristics(V_REF, ADC_ATTEN_11db, ADC_WIDTH_12Bit, &characteristics); */

    while(1)
    {
      memset(frame, 0, sizeof(frame));
      lcd_draw_pixel(frame, x, y);
      x = (x + 1) % SSD1306_LCDWIDTH;
      y = (y + 1) % SSD1306_LCDHEIGHT;
      /* frame[z] = 0x1; */
      /* z = (z + 1) % sizeof(frame); */
      uint8_t cmd1[] = {SSD1306_COLUMNADDR, 0, SSD1306_LCDWIDTH - 1};
      uint8_t cmd2[] = {SSD1306_PAGEADDR, 0, 7};
      lcd_cmd(spi, cmd1, sizeof(cmd1));
      lcd_cmd(spi, cmd2, sizeof(cmd2));
      lcd_data(spi, frame, sizeof(frame));
      gpio_set_level(PIN_NUM_DC, 0);
      // Read ADC and obtain result in mV
      int voltage = adc1_get_raw(ADC1_CHANNEL_6);
      printf("%d mV\n",voltage);
      //vTaskDelay(10);
    }
}
